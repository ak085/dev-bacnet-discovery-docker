# Telegraf Configuration for BacPipes
# MQTT â†’ TimescaleDB data pipeline

[agent]
  interval = "10s"
  round_interval = true
  metric_batch_size = 1000
  metric_buffer_limit = 10000
  collection_jitter = "0s"
  flush_interval = "10s"
  flush_jitter = "0s"
  precision = "0s"
  hostname = "bacpipes-telegraf"
  omit_hostname = false

###############################################################################
#                            INPUT PLUGINS                                    #
###############################################################################

# Subscribe to MQTT broker and receive sensor data
[[inputs.mqtt_consumer]]
  ## MQTT broker URLs
  servers = ["tcp://${MQTT_BROKER}:${MQTT_PORT}"]

  ## Topics to subscribe to
  ## Subscribe to all point data from all sites
  topics = [
    "+/+/+/presentValue",
    "+/+/+/+/presentValue"
  ]

  ## QoS level
  qos = 1

  ## Connection timeout
  connection_timeout = "30s"

  ## Client ID (unique identifier for this Telegraf instance)
  client_id = "telegraf_bacpipes"

  ## Username and password (if required by broker)
  # username = "telegraf"
  # password = "password"

  ## Data format
  data_format = "json_v2"

  ## JSON parsing configuration
  [[inputs.mqtt_consumer.json_v2]]
    ## Timestamp field
    timestamp_path = "timestamp"
    timestamp_format = "2006-01-02T15:04:05Z07:00"

    ## Tags (indexed fields for fast filtering)
    [[inputs.mqtt_consumer.json_v2.tag]]
      path = "siteId"
      rename = "site_id"
      optional = true

    [[inputs.mqtt_consumer.json_v2.tag]]
      path = "equipmentType"
      rename = "equipment_type"
      optional = true

    [[inputs.mqtt_consumer.json_v2.tag]]
      path = "equipmentId"
      rename = "equipment_id"
      optional = true

    [[inputs.mqtt_consumer.json_v2.tag]]
      path = "deviceName"
      rename = "device_name"
      optional = true

    [[inputs.mqtt_consumer.json_v2.tag]]
      path = "deviceIp"
      rename = "device_ip"
      optional = true

    [[inputs.mqtt_consumer.json_v2.tag]]
      path = "objectType"
      rename = "object_type"

    [[inputs.mqtt_consumer.json_v2.tag]]
      path = "pointName"
      rename = "point_name"

    [[inputs.mqtt_consumer.json_v2.tag]]
      path = "haystackName"
      rename = "haystack_name"
      optional = true

    [[inputs.mqtt_consumer.json_v2.tag]]
      path = "units"

    [[inputs.mqtt_consumer.json_v2.tag]]
      path = "quality"

    ## Fields (measured values)
    [[inputs.mqtt_consumer.json_v2.field]]
      path = "value"
      type = "float"

    [[inputs.mqtt_consumer.json_v2.field]]
      path = "deviceId"
      rename = "device_id"
      type = "int"

    [[inputs.mqtt_consumer.json_v2.field]]
      path = "objectInstance"
      rename = "object_instance"
      type = "int"

    [[inputs.mqtt_consumer.json_v2.field]]
      path = "pointId"
      rename = "point_id"
      type = "int"

    [[inputs.mqtt_consumer.json_v2.field]]
      path = "pollDuration"
      rename = "poll_duration"
      type = "float"
      optional = true

    [[inputs.mqtt_consumer.json_v2.field]]
      path = "pollCycle"
      rename = "poll_cycle"
      type = "int"
      optional = true

###############################################################################
#                            PROCESSOR PLUGINS                                #
###############################################################################

# Rename measurement to match TimescaleDB table name
[[processors.rename]]
  [[processors.rename.replace]]
    measurement = "mqtt_consumer"
    dest = "sensor_readings"

###############################################################################
#                            OUTPUT PLUGINS                                   #
###############################################################################

# Write to TimescaleDB (PostgreSQL) using SQL output
[[outputs.sql]]
  ## Database driver (postgres for TimescaleDB)
  driver = "postgres"

  ## Data source name (connection string)
  data_source_name = "host=${TIMESCALEDB_HOST} port=${TIMESCALEDB_PORT} user=${TIMESCALEDB_USER} dbname=${TIMESCALEDB_DB} sslmode=disable"

  ## Table to insert into
  table = "sensor_readings"

  ## Timestamp column
  timestamp_column = "time"

  ## Conversion function for tags/fields to columns
  ## This tells Telegraf how to map MQTT JSON to database columns
  [[outputs.sql.table_exists_function]]
    query = "SELECT to_regclass('sensor_readings')"

  ## Define column mappings
  [[outputs.sql.convert]]
    ## Measurement (table) name
    measurement = "sensor_readings"

    ## Map tags to columns
    [outputs.sql.convert.tags]
      site_id = "site_id"
      equipment_type = "equipment_type"
      equipment_id = "equipment_id"
      device_name = "device_name"
      device_ip = "device_ip"
      object_type = "object_type"
      point_name = "point_name"
      haystack_name = "haystack_name"
      units = "units"
      quality = "quality"

    ## Map fields to columns
    [outputs.sql.convert.fields_int]
      device_id = "device_id"
      object_instance = "object_instance"
      point_id = "point_id"
      poll_cycle = "poll_cycle"

    [outputs.sql.convert.fields_real]
      value = "value"
      poll_duration = "poll_duration"

# Console output for debugging (remove in production)
[[outputs.file]]
  files = ["stdout"]
  data_format = "influx"
